# К.р. 1

### Примечания:
- Считать, что вместо `{ ... }` -- корректные конструкции (в зависимости от...).
- Считать, что все необходимые заголовочные файлы подключены, нужный стандарт Си++ компилятором поддерживается.
- Считать, что все соотв. функции и методы классов определены.

---


### Шаблоны
#### 1. [Баллы: 0.5]
Имеется шаблонный класс, объявленный ниже:

```c++
template<class T1, class T2>
class c
{ ... };
```

Приведите пример частичной специализации данного класса для случая,
когда второй шаблонный параметр имеет тип `int`.

---

#### 2. [Баллы: 0.5 x 2]
Дан фрагмент кода:

```c++
// (1)
template<class T>
void f(const T &t)
{ ... }


// (2)
template<class T>
int f(const std::vector<T> &t)
{ ... }


// (3)
template<class T>
double f(const std::vector<T> &t, int x)
{ ... }
```

- Это скомпилируется? Почему?
- Какие из функций (1), (2) и (3) могут существовать (в одном пространстве имён) одновременно?

---

### Ссылки, семантика перемещения
#### 3. [Баллы: 0.5]
Какие значения содержатся в v1, v2, v3 после выполнения следующего фрагмента кода? Почему?

```c++
std::vector<int> v1{ 1, 2, 3 };		// => v1 содержит элементы 1, 2 и 3
std::vector<int> v2 = v1;
std::vector<int> v3 = std::move(v2);
```

---

#### 4. [Баллы: 0.5]
Какие конструкторы (или операторы присваивания?) будут вызваны в функции f в случаях (1) и (2)?

```c++
class c
{
public:
	// Конструктор по умолчанию (default constructor)
	c();
	
	// Конструктор копирования (copy constructor)
	c(const c &other);
	
	// Конструктор перемещения (move constructor)
	c(c &&other);
	
	// Оператор присваивания копированием (copy assignment)
	c & operator=(const c &other);
	
	// Оператор присваивания перемещением (move assignment)
	c & operator=(c &&other);
};


template<class T>
void f(T &&t)
{
	c x(std::forward<T>(t));	// <- интересует эта строчка
	// ...
}


int main()
{
	c c1;
	
	// (1)
	f(c1);
	
	// (2)
	f(std::move(c1));
	
	return 0;
}
```

---

### Многопоточность, средства синхронизации
#### 5. [Баллы: 0.5 x 2]
Дан фрагмент кода:

```c++
void f()
{ ... }


int main()
{
	std::thread th1(f), th2(f);
	
	th1.join();
	
	return 0;
}
```

- Это скомпилируется? Это будет работать? Почему? Как исправить?
- Сколько потоков (максимум) может одновременно работать в исправленной версии данной программы?

---

#### 6. [Баллы: 0.5 x 2 (+ 0.5 за хорошее решение проблем)]
Дан фрагмент кода:

```c++
std::mutex m1, m2;

void f1()
{
	m1.lock();
	m2.lock();
	
	m1.unlock();
}

void f2()
{
	m2.lock();
	m1.lock();
	
	m1.unlock();
	m2.unlock();
}
```

- Перечислите все проблемы (кроме глобальных переменных), которые возникнут при запуске функций f1 и f2 в разных потоках (как в вопросе № 5).
- Приведите (кратко) наилучший, на ваш взгляд, вариант решения каждой из них.

---

### Регулярные выражения (ECMAScript)
#### 7. [Баллы: 0.5]
Опишите (кратко), что означают символы `+`, `*` и `?` или приведите их эквиваленты в нотации `{a,b}`.

---

#### 8. [Баллы: 0.1 x 6, max: 0.5]
Дано регулярное выражение: `(-?[0-9a-f]+|[XVI]+)`

Проверяется соответствие полной строки данному регулярному выражению с помощью `std::regex_match` (не поиск подстроки).

Какие из следующих строк (без учёта номера строки с точкой и пробелом) ему соответствуют?

1. `1a2b3c`
2. `-abc`
3. `XV`
4. `-IV`
5. `123V`
6. `+XII`

---

### Посложнее на шаблоны
#### 9. [Баллы: 0.5 x 3 (+ 0.5, если сделаны все пункты)]
Дан фрагмент кода:

```c++
#include <type_traits>

int main()
{
	using a = ct_array<int, 1, 2, 3>;
	using b = ct_array<int, 4, 5, 6, 7>;
	using c = ct_array<char, 'a', 'b', 'c'>;
	
	
	// (1) Получение значения и размера
	std::cout << size<c>() << std::endl;	// "3"
	std::cout << get<c, 0>() << std::endl;	// "a"
	std::cout << get<c, 5>() << std::endl;	// Compilation error
	
	
	// (2) Конкатенация, ct_array<int, ...>, ct_array<int, ...>
	using ab = typename ct_cat<a, b>::type;
	static_assert(
		std::is_same<
			ab,
			ct_array<int, 1, 2, 3, 4, 5, 6, 7>
		>::value,
		
		"Types not match!"
	);
	
	// Конкатенация, ct_array<T1, ...>, ct_array<T2, ...>, T1 != T2
	using ac = typename ct_cat<a, c>::type;	// Compilation error
	
	
	// (3) Печать
	// Либо с использованием статических функций
	a::print();	// Печатает в std::cout: "1 2 3"
	c::print();	// Печатает в std::cout: "a b c"
	
	// Либо с использованием внешних функций -- как удобнее
	// print<a>();	// Печатает в std::cout: "1 2 3"
	// print<c>();	// Печатает в std::cout: "a b c"
	
	return 0;
}
```

Реализуйте шаблонные классы ct_array и ct_cat так, чтобы это работало соотв. образом.
Можно реализовать не все пункты (1), (2) и (3), если все не получаются. :)

*Подсказка 1 (пригодится обязательно):*
```c++
template<class T, T Value>	// <- Это работает, если T -- целочисленный тип
class test
{ ... };

test<int, 1005000>	// ОК
test<char, 'x'>		// ОК
test<double, 1.5>	// Не ОК!
```


*Подсказка 2 (поможет, если вдруг захотите хранить какие-то статические данные [можно и без этого]):*
```c++
template<class... Ts>
class test
{
	// В данном случае constexpr лучше писать (см. ниже)
	static constexpr int value = 100500;	// Инициализация прамо здесь
};

// Эти строчки написать нужно обязательно в заголовочном файле, после определения класса (не в каком-то .cpp)
template<class... Ts>
// static
constexpr int test<Ts...>::value;


// Зачем constexpr:
template<int Value>
class c
{ ... };

c<test<...>::value> // <- скомпилируется только если test<...>::value -- constexpr!
```
