# К.р. 1
#### Ответы автора
---


### Шаблоны
#### 1. [Баллы: 0.5]
Имеется шаблонный класс, объявленный ниже:

```c++
template<class T1, class T2>
class c
{ ... };
```

Приведите пример частичной специализации данного класса для случая,
когда второй шаблонный параметр имеет тип `int`.

**Ответ:**
```c++
template<class T>
class c<T, int>
{ ... };
```

---

#### 2. [Баллы: 0.5 x 2]
Дан фрагмент кода:

```c++
// (1)
template<class T>
void f(const T &t)
{ ... }


// (2)
template<class T>
int f(const std::vector<T> &t)
{ ... }


// (3)
template<class T>
double f(const std::vector<T> &t, int x)
{ ... }
```

- Это скомпилируется? Почему?
- Какие из функций (1), (2) и (3) могут существовать (в одном пространстве имён) одновременно?

**Ответ:**
Ребята, мой косяк: хотел дать задачу на частичную специализацию шаблонов функций, чтобы вы увидели, что это действительно не работает, но поленился скомпилировать простой с виду код.
Так что *это* скомпилируется и будет работать.
Ставил +1 за эту задачу всем, кто за неё взялся и в итоге не запутался в собственных объяснениях.

---

### Ссылки, семантика перемещения
#### 3. [Баллы: 0.5]
Какие значения содержатся в v1, v2, v3 после выполнения следующего фрагмента кода? Почему?

```c++
std::vector<int> v1{ 1, 2, 3 };		// => v1 содержит элементы 1, 2 и 3
std::vector<int> v2 = v1;
std::vector<int> v3 = std::move(v2);
```

**Ответ:**
v1 = { 1, 2, 3 }
Его скопировали, но не перемещали -- остался как был.

v2 -- пустой
Его переместили с помощью конструктора перемещения объекта v3.
Непосредственно std::move ничего не перемещала, но дала нам rvalue-ссылку на v2, что и позволило вызвать move constructor у v3.

v3 = { 1, 2, 3 }
Его переместили из v2. Замечу, что его элементы когда-то расположил в памяти ещё v2 в своём конструкторе копирования (из v1).

---

#### 4. [Баллы: 0.5]
Какие конструкторы (или операторы присваивания?) будут вызваны в функции f в случаях (1) и (2)?

```c++
class c
{
public:
	// Конструктор по умолчанию (default constructor)
	c();
	
	// Конструктор копирования (copy constructor)
	c(const c &other);
	
	// Конструктор перемещения (move constructor)
	c(c &&other);
	
	// Оператор присваивания копированием (copy assignment)
	c & operator=(const c &other);
	
	// Оператор присваивания перемещением (move assignment)
	c & operator=(c &&other);
};


template<class T>
void f(T &&t)
{
	c x(std::forward<T>(t));	// <- интересует эта строчка
	// ...
}


int main()
{
	c c1;
	
	// (1)
	f(c1);
	
	// (2)
	f(std::move(c1));
	
	return 0;
}
```

**Ответ:**
Здесь вообще нет присваиваний -- только конструкторы копирования (1) и перемещения (2).
Если не поняли разницу, изучите пример:
```c++
std::string str1;

// Конструкторы копирования и перемещения
// (т.к. объекты str2 и str3 только создаются)
str::string str2(str1);
str::string str3(std::move(str1));

// Операторы присваивания копированием и перемещением
// (т.к. str2 и str3 созданы ранее)
str2 = str1;
str3 = std::move(str1);
```

---

### Многопоточность, средства синхронизации
#### 5. [Баллы: 0.5 x 2]
Дан фрагмент кода:

```c++
void f()
{ ... }


int main()
{
	std::thread th1(f), th2(f);
	
	th1.join();
	
	return 0;
}
```

- Это скомпилируется? Это будет работать? Почему? Как исправить?
- Сколько потоков (максимум) может одновременно работать в исправленной версии данной программы?

**Ответ:**
Да, вполне нормально компилируется. Нет, это не работает. Если бы мы сделали `th2.join();` или `th2.detach();`, всё было бы ок, но т.к. мы этого не сделали, при выполнении деструктора объекта th2 наша программа будет "падать".

Замечу, что это не *страшная* ошибка вроде segmantation fault, просто класс `std::thread` побуждает нас обращаться с потоками аккуратно и ждать их завершения (`.join()`) либо отпускать их "в свободное плавание" явно (`.detach()`). Т.е. `std::thread` в своём деструкторе вполне осознанно "валит" программу *(и правильно делает)*.

Максимальное количество потоков здесь -- 3. Основной поток (с `main`) + 2 потока, связанные с объектами `th1` и `th2`.

---

#### 6. [Баллы: 0.5 x 2 (+ 0.5 за хорошее решение проблем)]
Дан фрагмент кода:

```c++
std::mutex m1, m2;

void f1()
{
	m1.lock();
	m2.lock();
	
	m1.unlock();
}

void f2()
{
	m2.lock();
	m1.lock();
	
	m1.unlock();
	m2.unlock();
}
```

- Перечислите все проблемы (кроме глобальных переменных), которые возникнут при запуске функций f1 и f2 в разных потоках (как в вопросе № 5).
- Приведите (кратко) наилучший, на ваш взгляд, вариант решения каждой из них.

**Ответ:**
1. Разный порядок захвата мьютексов в f1 и f2. Это приводит к deadlock-у обоих потоков.
2. В f1 забыли сделать `m2.unlock();`. Это приводит к deadlock-у потока с функцией f2.

Решение вручную исправить порядок захвата и добавить `m2.unlock();` -- формально рабочее в данном простом случае. До *идеального* решения оно не дотягивает очень сильно. Пример чуть сложнее, в котором показано, почему захват вручную, пусть и в "правильном" порядке -- плохое решение:
```c++
void f1(std::mutex &m1, std::mutex &m2)
{
	// 1. Блокируем в гарантированно одинаковом порядке, даже если кто-то перепутал мьютексы
	std::lock(m1, m2);
	
	// 2. Используем std:::lock_guard (или std::unique_lock),
	// чтобы не освобождать вручную
	std::lock_guard<std::mutex>
		l1(m1, std::adopt_lock),
		l2(m2, std::adopt_lock);
	
	// => Забыть освободить мьютексы (почти) невозможно,
	//    т.к. за этим следят l1 и l2
}

// f2 такая же, как f1

int main()
{
	std::mutex m1, m2;
	
	std::thread
		th1(f1, std::ref(m1), std::ref(m2)),
		th1(f1, std::ref(m2), std::ref(m1));
	// => Поменяли мьютексы местами,
	//    но std::lock сработает правильно
}
```

---

### Регулярные выражения (ECMAScript)
#### 7. [Баллы: 0.5]
Опишите (кратко), что означают символы `+`, `*` и `?` или приведите их эквиваленты в нотации `{a,b}`.

**Ответ:**
Халявные полбалла.
Пусть у нас выражения: `X+`, `X*`, `X?` (где `X` -- символ, класс символов или что-то ещё -- не важно). Тогда:
- `+` == {1,}  -- `X` встречается от одного раза (и более);
- `*` == {0,}  -- `X` встречается 0 и более раз;
- `?` == {0,1} -- `X` встречается 0 или 1 раз.

---

#### 8. [Баллы: 0.1 x 6, max: 0.5]
Дано регулярное выражение: `(-?[0-9a-f]+|[XVI]+)`

Проверяется соответствие полной строки данному регулярному выражению с помощью `std::regex_match` (не поиск подстроки с помощью `std::regex_search`).

Какие из следующих строк (без учёта номера строки с точкой и пробелом) ему соответствуют?

1. `1a2b3c`
2. `-abc`
3. `XV`
4. `-IV`
5. `123V`
6. `+XII`

**Ответ:**
Тоже халява, учитывая, что есть пример прямо по этой задаче:
1, 2, 3 -- соответствуют регулярке, остальные -- нет.

---

### Посложнее на шаблоны
#### 9. [Баллы: 0.5 x 3 (+ 0.5, если сделаны все пункты)]
Дан фрагмент кода:

```c++
#include <type_traits>

int main()
{
	using a = ct_array<int, 1, 2, 3>;
	using b = ct_array<int, 4, 5, 6, 7>;
	using c = ct_array<char, 'a', 'b', 'c'>;
	
	
	// (1) Получение значения и размера
	std::cout << size<c>() << std::endl;	// "3"
	std::cout << get<c, 0>() << std::endl;	// "a"
	std::cout << get<c, 5>() << std::endl;	// Compilation error
	
	
	// (2) Конкатенация, ct_array<int, ...>, ct_array<int, ...>
	using ab = typename ct_cat<a, b>::type;
	static_assert(
		std::is_same<
			ab,
			ct_array<int, 1, 2, 3, 4, 5, 6, 7>
		>::value,
		
		"Types not match!"
	);
	
	// Конкатенация, ct_array<T1, ...>, ct_array<T2, ...>, T1 != T2
	using ac = typename ct_cat<a, c>::type;	// Compilation error
	
	
	// (3) Печать
	// Либо с использованием статических функций
	a::print();	// Печатает в std::cout: "1 2 3"
	c::print();	// Печатает в std::cout: "a b c"
	
	// Либо с использованием внешних функций -- как удобнее
	// print<a>();	// Печатает в std::cout: "1 2 3"
	// print<c>();	// Печатает в std::cout: "a b c"
	
	return 0;
}
```

Реализуйте шаблонные классы ct_array и ct_cat так, чтобы это работало соотв. образом.
Можно реализовать не все пункты (1), (2) и (3), если все не получаются. :)

*Подсказка 1 (пригодится обязательно):*
```c++
template<class T, T Value>	// <- Это работает, если T -- целочисленный тип
class test
{ ... };

test<int, 1005000>	// ОК
test<char, 'x'>		// ОК
test<double, 1.5>	// Не ОК!
```


*Подсказка 2 (поможет, если вдруг захотите хранить какие-то статические данные [можно и без этого]):*
```c++
template<class... Ts>
class test
{
	// В данном случае constexpr лучше писать (см. ниже)
	static constexpr int value = 100500;	// Инициализация прамо здесь
};

// Эти строчки написать нужно обязательно в заголовочном файле, после определения класса (не в каком-то .cpp)
template<class... Ts>
// static
constexpr int test<Ts...>::value;


// Зачем constexpr:
template<int Value>
class c
{ ... };

c<test<...>::value> // <- скомпилируется только если test<...>::value -- constexpr!
```


**Ответ:**
Жаль, что эту задачу сделал только 1 человек. Задача не сложная, подсказки есть.

Моё решение несколько отличается, в паре мест, *возможно*, даже проще. Оно в файле `9.cpp`.

Оно опирается на подсказку 2 (т.к. это тупо проще понять -- разворачивание списка параметров в 1-м месте из 3-х возможных, а дальше -- работа с обычным массивом).

Замечу, что в реальности -- зависит от решаемой задачи. Иногда действительно надо сохранить шаблонные параметры, а иногда лучше разворачивать список.
