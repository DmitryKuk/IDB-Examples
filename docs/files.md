# IDB-Examples
#### Рекомендации по организации исходного кода
---

В больших проектах на Си++ весь код принято разделять на различные файлы. Это ускоряет как процесс навигации по вашим исходникам, так и процесс компиляции.

Как делать это правильно?

### Во-первых, надо разобраться, кто что и как собирает.
Вы используете систему сборки (например, `QMake`, `CMake` или `Boost.Build`).
Она делает следующие действия:
1. Вызывает компилятор для компиляции каждого `.cpp`-файла по-отдельности. Из каждого `.cpp` получается `.o` (или `.obj`, или ещё что-то -- зависит от вашего компилятора). Это -- объектный файл, в нём содержится скомпилированный код всех ваших функций из исходного `.cpp`. Но это ещё не готовая программа.
2. Если вы указали системе сборки, что какая-то часть вашего проекта (или даже весь) должна быть собрана в библиотеку, то система сборки запускает компилятор (или линковщик напрямую, но обычно всё-таки компилятор), даёт ему на вход все объектные файлы, которые войдут в библиотеку, и компилятор (при помощи линковщика) выдаёт:
	- `.so`/`.dylib`/`.dll`-файл, который является разделяемой библиотекой;
	- `.a`-файл (расширение зависит от вашей системы, компилятора и проч.), который является статически подключаемой библиотекой;
3. Если ваш проект сам по себе -- не библиотека, а приложение, то система сборки будет собирать исполняемый файл. Для этого она вызывает компилятор (или, опять же, линковщик), даёт ему на вход все нужные объектные файлы, разделяемые и статические библиотеки, и получает от компилятора, например, `.exe`.

Итого (например, в проекте lib1.cpp, lib2.cpp, main.cpp):
- lib1.cpp `->` lib1.o
- lib2.cpp `->` lib2.o
- main.cpp `->` main.o
- lib1.o, lib2.o `->` lib.so (или lib.a)
- main.o, lib.so (или lib.a) `->` что-то-там.exe

### Что насчёт обновления какого-то `.cpp`-файла?
Предположим, в примере выше вы обновили только файл lib1.cpp. Нормальная система сборки поймёт, что lib2.cpp и main.cpp перекомпилировать не надо, и выполнит следующие действия:
- lib1.cpp `->` lib1.o (т.к. зависит от lib1.cpp)
- lib1.o, lib2.o `->` lib.so (или lib.a) (т.к. зависит от lib1.o)
- main.o, lib.so (или lib.a) `->` что-то-там.exe (т.к. зависит от lib.so)

### Что насчёт заголовочных файлов?
Заголовочные файлы непосредственно обычно не участвуют в процессе компиляции (хотя иногда их прекомпилируют, но это сильно спицифичная для конкретного компилятора возможность), поэтому вопрос, что с ними делать, остаётся открытым. Продвинутые системы сборки (например, `Boost.Build`) умеют сами смотреть, какие заголовочные вы подключили, и сами строят правильную цепочку зависимостей. Если вдруг ваша система сборки туповата (случается же такое), она может, например, что-то не пересобирать. В любом случае обычно есть способы заставить её пересобрать всё принудительно.

### Разбиваем проект по файлам правильно
Здесь я приведу некоторые рекомендации, многие из которых не являются обязательными, но в каких-то случаях могут сильно упростить жизнь вам и вашим товарищам (читающим ваш код):
1. Вы пишете функцию или (о нет!) глобальную переменную:
	- Объявляете функцию в заголовочном файле `func.hpp`.
	- Если функция шаблонная или встраиваемая (в объявлении функции встречаются непонятные слова вроде `auto`, `template`, `inline`, `constexpr`), то её определение (т.е. объявление + тело, `{ ... }`) должно быть в заголовочном файле.
		+ Я очень рекомендую выносить в отдельный заголовочный файл (например, `func_impl.hpp`). Что и куда включать, см. ниже. Почему? -- Потому что ваши заголовочные файлы потом вам же будут служить справкой, они должны легко читаться.
	- Если функция не шаблонная, не встраиваемая и т.д., то её определение **должно** быть в файле `func.cpp`. Для сборки важно, чтобы оно было имено в каком-то одном `.cpp`-файле, для человека -- чтобы именно в `func.cpp` (для быстрого поиска).
	- Переменную объявляете в заголовочном файле с ключевым словом `extern`.
	- Определяете переменную **обязательно** в соотв. `.cpp`-файле (уже без слова `extern`).
2. Вы пишете (нешаблонный) класс:
	- Объявляете сам класс в файле `class.hpp`.
	- Если есть какие-то шаблонные, встраиваемые и т.д. методы или статические функции -- все их в `class_impl.hpp`.
	- Все нешаблонные функции -- в `class.cpp`.
	- Статические переменные класса -- в `class.cpp`.
3. Вы пишете шаблонный класс (подход, который я рекомендую):
	- Объявляете сам класс в `class.hpp`.
	- Все методы и статические функции, даже если они не встраиваемые и сами по себе не шаблонные, **должны** быть в заголовочном файле `class_impl.hpp`
	- В файл `class.cpp` писать вообще нечего, его можно даже не создавать.
	- Статические переменные класса -- в `class_impl.cpp`.
4. Вы пишете шаблонный класс (подход, который я не рекомендую из-за потери читаемости, зато так проще):
	- Объявляете класс в `class.hpp`.
	- Все члены класса определяете прямо по месту объявления, "внутри" класса.
		+ **Предупреждение:** так иногда проще писать, но почти всегда гораздо сложнее читать! Помните о товарищах и думаете, как сами будете читать это через некоторое время!
	- Статические переменные всё равно должны быть определены вне класса (да, даже если они `constexpr` и инициализированы "внутри" класса), но сделать это можно в том же `class.hpp` обязательно после объявления класса.
5. Если какие-то из ваших функций по смыслу тесно связаны друг с другом, их можно объявить в одном `.hpp` и определить в одном `.cpp` (или `_impl.hpp`).
	- **Примечание:** если функции (вдруг) получились большими по объёму, возможно, их не стоит объединять, а лучше сделать ещё один заголовочный файл, в который включить все необходимые заголовочные файлы с объявлениями функций. Это остаётся на ваше усмотрение.
6. Если какие-то классы по смыслу тесно связаны, их тоже можно объединить в один набор файлов.
	- **Примечание:** если для функций это ещё более-менее нормальный подход, то с классами надо быть осторожнее, т.к. у каждого и так свои методы, переменные и т.д. Опять же, можно сделать новый заголовочный файл, в который включить заголовочные файлы от всех классов.
7. Если вы решили, что объявить функции в одном `.hpp`, а определить в разных `.cpp` -- хорошая идея, то нет, это совсем не хорошая идея. Совсем. Даже "ну одну функцию"!
8. То же, что в п.7, но относится к определению методов класса. Любого класса. Даже нешаблонного. И к статическим переменным тоже. Даже если она одна такая, и создавать `.cpp` ради неё вам лень.
9. Жизнь всё-таки заставила вас написать больше, чем один `.cpp`, и вы поняли, что с заголовочными файлами начались проблемы. Правила написания заголовочных файлов:
	- Защита от повторных включений:
		+ В каждом заголовочном файле (`my_file.hpp`) используете т.н. include guard:
			* В начале файла пишете:
			```c++
			#ifndef MY_FILE_HPP
			#define MY_FILE_HPP
			```
			* В конце файла пишете:
			```c++
			#endif	// MY_FILE_HPP
			```
		+ Если файл лежит во вложенном каталоге (например, `net/http/my_file.hpp`), то вместо `MY_FILE_HPP` стоит писать `NET_HTTP_MY_FILE_HPP`
			* Почему так? -- Потому что в проекте вполне могут встретиться файлы с одим и тем же именет, но в разных каталогах. Если они будут подключены в одном месте, то include guard не только защитит ваши заголовочники от повторных включений, но ещё и не даст включить какие-то из них.
		+ Технически (обычно) есть возможность писать без include guards:
			* `#pragma once` в начале соотв. заголовочных файлов.
			* **Внимание:** это не лучший способ, потому что директивы `#pragma` никто не стандартизировал -- в вашем компиляторе может быть, в компиляторе вашего товарища -- как повезёт. Вроде бы, по слухам, это не настолько страшная проблема (т.к. в основных компиляторах пожжерживается), но гарантий никаких.
	- Объявления -- в `file.hpp`, определения (реализация) -- в `file_impl.hpp`
10. Группировка файлов по каталогам:
	- Все файлы с исходниками лежат в подкаталогах каталога `src/` (который обязательно присутствует в корне проекта).
	- Все 1, 2 или 3 файла с объявлением и определением одного класса/функции лежат в однои каталоге. Если "переезжают" -- то только вместе.
	- Если несколько сущностей (классов, функций) по смыслу близки друг к другу и могут быть легко отделены от остальных, файлы с ними "едут" в соотв. подкаталог. Примеры:
		+ Классы, отвечающие за панель в GUI `->` `panel/`.
		+ Класса и функции, отвечающие за работу с сетью `->` `net/`.
		+ Классы и функции, отвечающие за работу с файловой системой `->` `fs/`.

### Итого
Пусть данные файлы находятся в каталоге: `src/path/to/`.

#### Пример `file.hpp`
```c++
// Комментарий об авторе, с именем, почтой, датой и временем создания
// Комментарии о редактировавших файл (вписывайтесь, если написали существенную часть), чтобы проще было найти виновного (дата и время тоже нужны)

#ifndef PATH_TO_FILE_HPP
#define PATH_TO_FILE_HPP

#include <iostream>	// Всё, что нужно для объявления ваших классов/функций

// Объявления

// Обязательно в конце файла, но внутри защиты
// Это единственное место, где должен быть подключен этот файл -- остальные подключают "file.hpp"
#include "file_impl.hpp"

#endif	// PATH_TO_FILE_HPP
```

#### Пример `file_impl.hpp`
```c++
// Комментарии об авторе и редактировавших

// Защита не обязательна, т.к. никто (кроме file.hpp) напрямую не будет подключать этот файл

#include <...>	// Те заголовочные файлы, которые не нужны были при объявлении, но теперь понадобились

// Определения всего, что нужно
```

#### Пример `file.cpp`
```c++
// Комментарии об авторе и редактировавших

#include "file.hpp"

#include <...>	// Те заголовочные файлы, которые не нужны были при объявлении, но теперь понадобились

// Определения всего, что нужно
```


---
Дмитрий Куковинец <d1021976@gmail.com>, 19.10.2016, 15:42
